import osimport reimport smtplibimport sysimport threadingfrom multiprocessing import Process, Queueimport timeimport urllibfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport seleniumfrom appium import webdriverfrom selenium.webdriver.support.wait import WebDriverWait"""    脚本功能:            检测指定目录下是否有apk文件,有的话自动执行安装过程(自动安装仅限oppoR7),如果没有则继续等待直到apk文件出现;            安装后调出广告和信息流,然后执行back,home,冷启动的时间测试;            首轮测试结束后卸载apk,安装比对版本的apk进行第二轮测试;            测试完毕后收集测试数据输出图形报告;            测试报告邮件发送;    测试环境:            测试前请确保手机内已安装有双开助手apk(版本不限,仅为开启appium-server使用);            测试前请确保手机内至少装有一款热门应用(如微信等);"""email_content_flag = 1alert_flag = 1pck_name = 'com.excelliance.dualaid'activity = 'com.excelliance.kxqp.ui.HelloActivity'class FilePath(object):    def __init__(self, apk_path, style='.apk'):        self.apk_path = apk_path        self.style = style    def get_file_path(self):        """获取daily review安装包路径"""        for file in os.listdir(self.apk_path):            file_path = os.path.join(self.apk_path, file)            if self.style in file_path and os.path.isfile(file_path):                return file_path    def check_adb_connect(self):        """查看USB是否已连接"""        text = os.popen('adb devices')        time.sleep(5)        if 'device' in text.readlines()[1]:            return True        else:            print('USB未连接')            return False    def uninstall_apk(self):        """卸载本机已有双开助手apk"""        if 'com.excelliance.dualaid' in os.popen('adb shell pm list package -3 | findstr "excelliance"').read():            os.popen('adb uninstall com.excelliance.dualaid')    def install_apk(self):        """安装daily review包"""        os.popen('adb install -r ' + self.get_file_path())        while True:            try:                if "com.android.packageinstaller:id/apk_info_view" in driver.page_source:                    print('正在安装apk')                    time.sleep(1)                    driver.find_element_by_xpath('//*[@text="继续安装"]').click()                    time.sleep(1)                    driver.find_element_by_xpath('//*[@text="安装"]').click()                    time.sleep(2)                    driver.find_element_by_xpath('//*[@text="完成"]').click()                    print('apk安装完成')                    break                else:                    time.sleep(2)            except selenium.common.exceptions.NoSuchElementException:                print('apk安装失败，正在尝试重新安装')            except selenium.common.exceptions.WebDriverException:                print('appium连接出错，正在重新连接')                app.stop_appium_server()                time.sleep(2)                app.check_appium_server()                time.sleep(2)    def monitor(self):        """        检查本机是否有daily review包同名apk，如果有就删除，如果没有就去指定目录检查，有apk包就执行安装，没有就等待，        直到安装成功为止，安装完成后将该目录下的安装包移动至存放apk的目录        """        if self.check_adb_connect() is True:            self.uninstall_apk()            time.sleep(2)            while True:                try:                    self.install_apk()                    print('开始配置测试环境')                    break                except TypeError:                    print('未检测到双开助手安装包\n本次检测时间：%s' % time.strftime('%Y.%m.%d_%H:%M:%S'))                    time.sleep(10)# appium封装class AppiumServerCheck(object):    # 查看USB连接状态    def check_adb_connect(self):        text = os.popen('adb devices').readlines()        if 'device' in text[1]:            return True        else:            print('USB未连接')            return False    def appium_init(self):        """to initialise appium session"""        desired_cups = {}        global driver        desired_cups['platformName'] = 'Android'        desired_cups['platformVersion'] = '5.1.1'        desired_cups['deviceName'] = '900ca8ab'        desired_cups['appPackage'] = pck_name        desired_cups['appActivity'] = activity        desired_cups['autoLaunch'] = 'false'        desired_cups['noReset'] = 'true'        desired_cups['automationName'] = 'uiautomator2'        driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub', desired_cups)        return driver    def quit(self):        """to quit this session"""        driver.quit()    def app_start(self):        os.popen('adb shell am start ' + pck_name + '/' + activity)    def app_back(self):        os.popen('adb shell input keyevent 4')    def app_home(self):        os.popen('adb shell input keyevent 3')    def app_force_stop(self):        os.popen('adb shell am force-stop ' + pck_name)    def app_data_clear(self):        os.popen('adb shell pm clear ' + pck_name)    def wait_for(self, n=2):        """硬等待"""        time.sleep(n)    def wait_for_element(self, controlinfo, time=20, frequency=1):        """显式等待元素出现（直到until方法执行完毕，或者等待10秒后等待取消）"""        if r'//*' in controlinfo:            try:                WebDriverWait(driver, time, frequency).until(lambda driver: driver.find_element_by_xpath(controlinfo))            except selenium.common.exceptions.WebDriverException:                print('等待元素%s出错' % controlinfo)        elif r'id/' in controlinfo:            try:                WebDriverWait(driver, time, frequency).until(lambda driver: driver.find_element_by_id(controlinfo))            except selenium.common.exceptions.WebDriverException:                print('等待元素%s出错' % controlinfo)    # 检测appium服务是否已开启，如未开启则自动开启服务进行初始化    # 如已开启直接进行初始化    def check_appium_server(self):        if self.check_adb_connect() is True:            if 'node.exe' in os.popen('tasklist | findstr "node.exe"').read():                while True:                    try:                        self.appium_init()                        break                    except ConnectionRefusedError:                        self.wait_for(3)                    except urllib.error.URLError:                        self.wait_for(3)                self.app_force_stop()                print('appium初始化完成')            else:                os.popen("start appium")                print("正在启动appium服务程序，请稍等...")                while True:                    if 'node.exe' in os.popen('tasklist | findstr "node.exe"').read():                        while True:                            try:                                self.appium_init()                                break                            except ConnectionRefusedError:                                self.wait_for(3)                            except urllib.error.URLError:                                self.wait_for(3)                        self.app_force_stop()                        print('appium初始化完成')                        break                    else:                        self.wait_for(1)                        continue        else:            sys.exit()    def stop_appium_server(self):        # 结束appium进程（Windows适用）        pid_node = os.popen('tasklist | findstr "node.exe"').readlines()        for i in pid_node:            os.popen('taskkill /f /pid ' + i.split()[1])        pid_cmd = os.popen('tasklist | findstr "cmd.exe"').readlines()        for i in pid_cmd:            os.popen('taskkill /f /pid ' + i.split()[1])    def get_middle_coordinate(self):        """获取手机屏幕中心点坐标"""        list = []        x = (driver.get_window_size()['width'])        y = (driver.get_window_size()['height'])        list.append(x)        list.append(y)        return list    def swipe_left(self, t=300):        """左滑"""        L = self.get_middle_coordinate()        x1 = int(L[0] * 0.9)        y1 = int(L[1] * 0.5)        x2 = int(L[0] * 0.1)        driver.swipe(x1, y1, x2, y1, t)    def swipe_right(self, t=300):        """右滑"""        L = self.get_middle_coordinate()        x1 = int(L[0] * 0.1)        y1 = int(L[1] * 0.5)        x2 = int(L[0] * 0.9)        driver.swipe(x1, y1, x2, y1, t)    def swipe_up(self, t=500):        """上滑"""        L = self.get_middle_coordinate()        x1 = int(L[0] * 0.5)        y1 = int(L[1] * 0.8)        y2 = int(L[1] * 0.4)        driver.swipe(x1, y1, x1, y2, t)    def swipe_down(self, t=500):        """下滑"""        L = self.get_middle_coordinate()        x1 = int(L[0] * 0.5)        y1 = int(L[1] * 0.4)        y2 = int(L[1] * 0.8)        driver.swipe(x1, y1, x1, y2, t)    def swipe_find_element(self, controlinfo, t=500, direction='U'):        """swipe down to find element whitch you want"""        count = 5        while count > 0:            try:                if '//' in controlinfo:                    driver.find_element_by_xpath(controlinfo).click()                elif ':id/' in controlinfo:                    driver.find_element_by_id(controlinfo).click()                break            except Exception:                count -= 1                if direction == 'U':                    self.swipe_up(t)                    self.wait_for(1)                elif direction == 'D':                    self.swipe_down(t)                    self.wait_for(1)                elif direction == 'L':                    self.swipe_left(t)                    self.wait_for(1)                elif direction == 'R':                    self.swipe_right(t)                    self.wait_for(1)# 进程创建/结束class CreateProcess(object):    def start_process(self, func):        global process_flag        process_flag = 1        p = Process(target=func)        p.start()    def stop_process(self):        global process_flag        process_flag = 0        time.sleep(2)# 线程创建/结束class CreateThread(object):    def start_thread(self, func):        """开启一条执行func函数的新线程"""        global alert_flag        alert_flag = 1        thread = threading.Thread(target=func)        thread.start()    def stop_thread(self):        global alert_flag        alert_flag = 0        while True:            if threading.active_count() > 1:                time.sleep(2)            else:                # print('当前线程数：%d' % threading.active_count())                break# 弹窗处理class SuperVision(object):    ap = AppiumServerCheck()    def update_alert(self):        """监控并处理应用安装弹窗"""        print('监控1已启动')        while alert_flag == 1:            try:                if 'com.excelliance.dualaid:id/ll_dialog' in driver.page_source:                    print('检测到apk更新提示，正在处理...')                    driver.find_element_by_id('com.excelliance.dualaid:id/cb_noToast').click()                    driver.find_element_by_id('com.excelliance.dualaid:id/tv_left').click()                    print('已忽略apk更新')                    break                else:                    time.sleep(2)            except selenium.common.exceptions.NoSuchElementException:                print('处理失败')            except selenium.common.exceptions.WebDriverException:                app.stop_appium_server()                time.sleep(2)                app.check_appium_server()                time.sleep(2)    def pemission_alert(self):        print('监控2已启动')        while alert_flag == 1:            try:                if "oppo:id/permission_prompt" in driver.page_source:                    print('检测到apk权限弹窗，正在处理...')                    driver.find_element_by_xpath('//*[@text="不再提醒"]').click()                    driver.find_element_by_xpath('//*[@text="允许"]').click()                    # driver.find_element_by_android_uiautomator('new UiSelector().text("不再提醒")').click()                    # driver.find_element_by_android_uiautomator('new UiSelector().text("允许")').click()                    print('已同意apk获取权限')                else:                    time.sleep(2)            except selenium.common.exceptions.NoSuchElementException:                print('处理失败')            except selenium.common.exceptions.StaleElementReferenceException:                print('处理失败')            except selenium.common.exceptions.WebDriverException:                app.stop_appium_server()                time.sleep(2)                app.check_appium_server()                time.sleep(2)# 邮件发送测试报告class EmailSending(object):    def __init__(self, username, password):        self.username = username        self.password = password    # 创建并发送邮件    def create_email(self, t):        username = self.username        password = self.password        smtpserver = 'smtp.ym.163.com'        sender = username        receiver = 'wangzhongchang@excelliance.cn'        # receiver = 'xuhe@excelliance.cn,wangzhe@excean.com,huanggao@excelliance.cn,liminde@excelliance.cn,\        #             zhuyao@excean.com,lixianzhuang@excelliance.cn,wangzhongchang@excelliance.cn'        # 通过Header对象编码的文本，包含utf-8编码信息和Base64编码信息。以下中文名测试ok        subject = '测试报告'        subject = Header(subject, 'utf-8').encode()        # 构造邮件对象MIMEMultipart对象        msg = MIMEMultipart('mixed')        msg['Subject'] = subject        msg['From'] = sender        msg['To'] = receiver        # 构造邮件内容（html形式）        # 判断是否拉取到信息流        if email_content_flag == 1:            mail_content = """            <div>            <p><strong>启动时间测试报告(时间间隔为%d)</strong></p>            <p>测试数据单位均为毫秒（ms）</p>            <div id="content">            <table border="1" bordercolor="#87ceeb" width="800">                <tr>                    <td>版本</td>                    <td>back(avg)</td>                    <td>back(max)</td>                    <td>home(avg)</td>                    <td>home(max)</td>                    <td>冷启动(avg)</td>                    <td>冷启动(max)</td>                </tr>                <tr>                    <td>新版本</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                </tr>                <tr>                    <td>3.0.6版本</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                    <td>%d</td>                </tr>                <tr>                    <td>均值差</td>                    <td>%d</td>                    <td bgcolor="#87ceeb">null</td>                    <td>%d</td>                    <td bgcolor="#87ceeb">null</td>                    <td>%d</td>                    <td bgcolor="#87ceeb">null</td>                </tr>            </table>            </div>            </div>            </body>            </html>            """ % (t, data_dict['新版back均值'], data_dict['新版back最大值'], data_dict['新版home均值'],                   data_dict['新版home最大值'], data_dict['新版force均值'], data_dict['新版force最大值'],                   data_dict['老版back均值'], data_dict['老版back最大值'], data_dict['老版home均值'],                   data_dict['老版home最大值'], data_dict['老版force均值'], data_dict['老版force最大值'],                   data_dict['back差值'], data_dict['home差值'], data_dict['force差值']                   )        else:            mail_content = """                        <h1>启动时间自动化测试失败<h1>                        <p>失败原因：5次拉取信息流失败（以尝试调节系统时间后再拉取）</p>                        """        text = MIMEText(mail_content, 'html', 'utf-8')        msg.attach(text)        # 发送邮件        smtp = smtplib.SMTP()        smtp.connect(smtpserver, 25)        smtp.login(username, password)        smtp.sendmail(sender, receiver.split(','), msg.as_string())        smtp.quit()# app启动时间测试类class StartTimeTest(AppiumServerCheck):    def __init__(self):        self.list_back_test = []        self.list_home_test = []        self.list_force_test = []        self.list_back_std = []        self.list_home_std = []        self.list_force_std = []    # 启动并获取启动时间    def start_and_get_date(self):        # 正则匹配方式获取        time_data = os.popen('adb shell am start -W ' + pck_name + '/' + activity).read()        b = re.search(r'(TotalTime:)\s(\d+)', time_data)        app_start_time = b.group(2)        # 循环方式获取        # time_data = os.popen('adb shell am start -W ' + pck_name + '/' + activity).readlines()        # for i in time_data:        #     if 'TotalTime' in i:        #         app_start_time = i.split(':')[1].strip()        #         return int(app_start_time)        return int(app_start_time)    # 设置手机（oppoR7）系统时间    def set_phone_time(self, kind='normal'):        if kind == 'normal':            print('设置系统时间')            self.app_back()            self.wait_for(1)            self.app_back()            self.wait_for(1)            self.app_home()            self.wait_for(1)            try:                driver.find_element_by_xpath('//*[@text="设置"]').click()            except selenium.common.exceptions.NoSuchElementException:                self.app_home()                time.sleep(1)                driver.find_element_by_xpath('//*[@text="设置"]').click()            try:                self.swipe_find_element('//*[@text="日期和时间"]')            except Exception:                self.swipe_find_element('//*[@text="日期和时间"]')            except Exception:                print('设置手机时间失败')            if driver.find_element_by_xpath('//*[@text="设置日期"]').is_enabled() is False:                driver.find_elements_by_id('android:id/checkbox')[0].click()                self.wait_for(1)                driver.find_element_by_xpath('//*[@text="设置日期"]').click()                self.wait_for(1)                driver.find_elements_by_id('oppo:id/increment')[1].click()                self.wait_for(1)                driver.find_element_by_id('android:id/button1').click()            else:                driver.find_element_by_xpath('//*[@text="设置日期"]').click()                self.wait_for(1)                driver.find_elements_by_id('oppo:id/increment')[1].click()                self.wait_for(1)                driver.find_element_by_id('android:id/button1').click()            self.app_home()            self.wait_for(1)            self.app_start()            self.wait_for_element('com.excelliance.dualaid:id/add_but')        elif kind == 'recovery':            print('恢复系统时间')            self.app_home()            time.sleep(1)            try:                driver.find_element_by_xpath('//*[@text="设置"]').click()            except selenium.common.exceptions.NoSuchElementException:                self.app_home()                time.sleep(1)                driver.find_element_by_xpath('//*[@text="设置"]').click()            while True:                try:                    self.swipe_find_element('//*[@text="日期和时间"]')                    break                except selenium.common.exceptions.NoSuchElementException:                    continue            if driver.find_element_by_xpath('//*[@text="设置日期"]').is_enabled() is True:                driver.find_elements_by_id('android:id/checkbox')[0].click()                self.app_home()                self.wait_for(1)                self.app_start()                self.wait_for_element('com.excelliance.dualaid:id/add_but')    def set_app_status(self):        """启动APP至状态（有banner，icon，无信息流，无钻石按钮的主界面）"""        def set_step():            self.wait_for(3)            self.swipe_find_element('com.excelliance.dualaid:id/bt_explore', 300, 'L')            self.wait_for_element('com.excelliance.dualaid:id/jump_to')            driver.find_element_by_id('com.excelliance.dualaid:id/jump_to').click()            self.wait_for_element('com.excelliance.dualaid:id/tv_bt_add', 30, 1)            self.app_back()            self.wait_for()            self.app_back()            self.wait_for()            self.app_start()        set_step()        i = 0        while i <= 3:            i += 1            try:                self.wait_for_element('com.excelliance.dualaid:id/ad_but', 30, 1)                print('正在检测非标位')                if 'com.excelliance.dualaid:id/fl_off_standard_position' in driver.page_source:                    print('拉取到非标位版本，重新拉取')                    # 检测到非标位，清除数据重新拉取版本                    self.app_data_clear()                    self.wait_for()                    self.app_start()                    self.set_app_status()                else:                    print('不带非标位版本，继续测试')                    break            except selenium.common.exceptions.TimeoutException:                print("广告拉取失败%d次" % i)                if i == 3:                    self.set_phone_time()                    self.set_app_status()                else:                    self.app_back()                    self.wait_for()                    self.app_start()            except selenium.common.exceptions.WebDriverException:                print('appium服务器出错，正在重新连接')                self.stop_appium_server()                time.sleep(2)                self.check_appium_server()                time.sleep(2)    # 设置测试环境（拉取广告及信息流）    def set_until_find_ad(self):        self.app_start()        self.wait_for()        try:            self.set_app_status()            driver.find_element_by_id('com.excelliance.dualaid:id/iv_close').click()            print('主界面引导关闭成功')        except selenium.common.exceptions.NoSuchElementException:            print('主界面引导关闭失败')        except selenium.common.exceptions.TimeoutException:            print('未拉取到广告')        # 添加微信        try:            print('正在添加微信')            driver.find_element_by_xpath('//*[@text="微信"]').click()            while True:                if driver.find_element_by_id('com.excelliance.dualaid:id/tv_app_add').is_displayed() is False:                    print('正在添加...')                    self.wait_for(1)                else:                    print('微信添加成功')                    self.app_back()                    break        except Exception:            print('微信添加失败')        # 调出信息流        self.set_phone_time()        i = 1        while i < 6:            print('第%s次拉取信息流' % i)            self.wait_for_element('双开助手', 15, 1)            if 'com.excelliance.dualaid:id/tv_title' in driver.page_source:                self.app_back()                print('信息流拉取成功，开始进行调试')                time.sleep(2)                break            else:                print('拉取信息流失败，尝试重新拉取')                # 3次拉取失败的话，恢复系统时间再试                if i == 3:                    self.set_phone_time(kind='recovery')                # 5次拉取失败的话，邮件通知拉取不到信息流                elif i == 5:                    global email_content_flag                    email_content_flag = 0                    em = EmailSending('wangzhongchang@excelliance.cn', 'wzc6851498')                    em.create_email(t)                    time.sleep(5)                    sys.exit()                else:                    self.set_phone_time(kind='normal')            i += 1    # back场景测试    def test_back(self, t):        list_back = []        self.app_back()        time.sleep(t)        self.app_start()        time.sleep(t)        self.app_back()        time.sleep(t)        print('调试结束，测试开始\n场景一：back')        # while len(list_back) < 12:        #     start_time = self.start_and_get_date()        #     try:        #         self.wait_for_element('com.excelliance.dualaid:id/tv_title', 20, 1)        #     except selenium.common.exceptions.NoSuchElementException:        #         print('未拉取到信息流')        #         continue        #     except selenium.common.exceptions.WebDriverException:        #         print('appium服务器出错，正在重新连接')        #         self.stop_appium_server()        #         time.sleep(2)        #         self.check_appium_server()        #         time.sleep(2)        #     if 0 < start_time < 500:        #         list_back.append(round(start_time))        #     self.app_back()        #     time.sleep(t)        while len(list_back) < 12:            if self.check_adb_connect() is True:                start_time = self.start_and_get_date()                time.sleep(3)                if 0 < start_time < 500:                    list_back.append(start_time)                if self.check_adb_connect() is True:                    self.app_back()                    time.sleep(t)                else:                    time.sleep(2)            else:                time.sleep(2)        # 去掉一个最大值和一个最小值        list_back.remove(max(list_back))        list_back.remove(min(list_back))        print(list_back)        print(sum(list_back)/len(list_back))        return list_back    # home场景测试    def test_home(self, t):        list_home = []        self.app_start()        time.sleep(t)        self.app_home()        time.sleep(t)        self.app_start()        time.sleep(t)        self.app_home()        time.sleep(t)        print('调试结束，测试开始\n场景二：home')        # while len(list_home) < 12:        #     start_time = self.start_and_get_date()        #     try:        #         self.wait_for_element('com.excelliance.dualaid:id/tv_title', 20, 1)        #     except selenium.common.exceptions.NoSuchElementException:        #         print('未拉取到信息流')        #         continue        #     except selenium.common.exceptions.WebDriverException:        #         print('appium服务器出错，正在重新连接')        #         self.stop_appium_server()        #         time.sleep(2)        #         self.check_appium_server()        #         time.sleep(2)        #     if 0 < start_time:        #         list_home.append(round(start_time))        #     self.app_home()        #     time.sleep(t)        while len(list_home) < 12:            if self.check_adb_connect() is True:                start_time = self.start_and_get_date()                time.sleep(3)                if 0 < start_time < 500:                    list_home.append(start_time)                if self.check_adb_connect() is True:                    self.app_home()                    time.sleep(t)                else:                    time.sleep(2)            else:                time.sleep(2)        # 去掉一个最大值和一个最小值        list_home.remove(max(list_home))        list_home.remove(min(list_home))        print(list_home)        print(sum(list_home)/len(list_home))        return list_home    # 冷启动场景测试    def test_force(self, t):        list_force = []        self.app_force_stop()        time.sleep(t)        self.app_start()        time.sleep(t)        self.app_force_stop()        time.sleep(t)        print('调试结束，测试开始\n场景三：冷启动')        # while len(list_force) < 12:        #     start_time = self.start_and_get_date()        #     try:        #         self.wait_for_element('com.excelliance.dualaid:id/tv_title', 20, 1)        #     except selenium.common.exceptions.NoSuchElementException:        #         print('未拉取到信息流')        #         continue        #     except selenium.common.exceptions.WebDriverException:        #         print('appium服务器出错，正在重新连接')        #         self.stop_appium_server()        #         time.sleep(2)        #         self.check_appium_server()        #         time.sleep(2)        #     if 0 < start_time < 1200:        #         list_force.append(round(start_time))        #     else:        #         continue        #     self.app_force_stop()        #     time.sleep(t)        while len(list_force) < 12:            if self.check_adb_connect() is True:                start_time = self.start_and_get_date()                time.sleep(3)                if 0 < start_time:                    list_force.append(start_time)                if self.check_adb_connect() is True:                    self.app_force_stop()                    time.sleep(t)                else:                    time.sleep(2)            else:                time.sleep(2)        # 去掉一个最大值和一个最小值        list_force.remove(max(list_force))        list_force.remove(min(list_force))        print(list_force)        print(sum(list_force)/len(list_force))        return list_force    # 启动并收集测试数据（新版本）    def test_and_get_data1(self, t):        # 将app调试到可测环境(调出广告和信息流)        self.set_until_find_ad()        self.app_start()        self.wait_for()        # 开始场景一测试        # 停止监控线程        global new_thread        new_thread.stop_thread()        # 停止appium服务端程序        try:            self.quit()            print('appium会话断开成功')            self.stop_appium_server()        except ConnectionRefusedError:            print('断开appium服务出错，已跳过')        except urllib.error.URLError:            print('断开appium服务出错，已跳过')        self.list_back_test = self.test_back(t)        time.sleep(2)        # 开始场景二测试        self.list_home_test = self.test_home(t)        time.sleep(2)        # 开始场景三测试        self.list_force_test = self.test_force(t)        time.sleep(2)    # 启动并收集测试数据（3.0.6版本）    def test_and_get_data2(self, t):        # 将app调试到可测环境(调出广告和信息流)        self.set_until_find_ad()        self.app_start()        time.sleep(2)        # 开始场景一测试        # 停止监控线程        global new_thread        new_thread.stop_thread()        # 停止appium服务端程序        try:            self.quit()            print('appium会话断开成功')            self.stop_appium_server()        except ConnectionRefusedError:            print('断开appium服务出错，已跳过')        except urllib.error.URLError:            print('断开appium服务出错，已跳过')        self.list_back_std = self.test_back(t)        time.sleep(2)        # 开始场景二测试        self.list_home_std = self.test_home(t)        time.sleep(2)        # 开始场景三测试        self.list_force_std = self.test_force(t)        time.sleep(2)    # 启动测试入口    def run_test(self, t):        if self.check_adb_connect() is False:            sys.exit()        # 初始化appium连接        self.check_appium_server()        # 初始化弹窗监控线程        global new_thread        alert = SuperVision()        new_thread = CreateThread()        new_thread.start_thread(alert.update_alert)        new_thread.start_thread(alert.pemission_alert)        # apk安装检测        install = FilePath(r'Z:\start_time_SKZS')        # install = FilePath(r'Z:\start_time_SKZS\start_time_files\apk', style='3.0.6')        install.monitor()        # # 保存本次测试apk        # os.popen('move ' + install.get_file_path() + ' ' + r'Z:\start_time_SKZS\start_time_files\apk')        print('阶段一：新版本测试')        self.test_and_get_data1(t)        # 初始化appium连接        self.check_appium_server()        # 开启监控线程        new_thread.start_thread(alert.update_alert)        new_thread.start_thread(alert.pemission_alert)        # 切换app版本至比对版本(3.0.6)        # install = FilePath(r'Z:\start_time_SKZS')        install = FilePath(r'Z:\start_time_SKZS\start_time_files\apk', style='3.0.6')        install.monitor()        time.sleep(2)        print('阶段二：3.0.6版本测试')        self.test_and_get_data2(t)        # 计算需要输出的数据        def avg(list):            average = sum(list) / len(list)            return average        # 新版平均值        t_b_avg = avg(self.list_back_test)        t_h_avg = avg(self.list_home_test)        t_f_avg = avg(self.list_force_test)        # 306版平均值        s_b_avg = avg(self.list_back_std)        s_h_avg = avg(self.list_home_std)        s_f_avg = avg(self.list_force_std)        # 新版最大值        t_b_max = max(self.list_back_test)        t_h_max = max(self.list_home_test)        t_f_max = max(self.list_force_test)        # 306版最大值        s_b_max = max(self.list_back_std)        s_h_max = max(self.list_home_std)        s_f_max = max(self.list_force_std)        # 平均值差值        b_diff = t_b_avg - s_b_avg        h_diff = t_h_avg - s_h_avg        f_diff = t_f_avg - s_f_avg        # 收集输出数据至指定集合        global data_dict        data_dict = {            '新版back均值': t_b_avg,            '新版home均值': t_h_avg,            '新版force均值': t_f_avg,            '老版back均值': s_b_avg,            '老版home均值': s_h_avg,            '老版force均值': s_f_avg,            '新版back最大值': t_b_max,            '新版home最大值': t_h_max,            '新版force最大值': t_f_max,            '老版back最大值': s_b_max,            '老版home最大值': s_h_max,            '老版force最大值': s_f_max,            'back差值': b_diff,            'home差值': h_diff,            'force差值': f_diff        }        return data_dictif __name__ == '__main__':    thread = CreateThread()    app = AppiumServerCheck()    test = StartTimeTest()    e = EmailSending('wangzhongchang@excelliance.cn', 'wzc6851498')    while True:        try:            t = 2            test.run_test(t)            e.create_email(t)            time.sleep(20)        except Exception:            try:                driver.quit()                print('appium连接已断开')                time.sleep(2)                app.stop_appium_server()                time.sleep(2)            except ConnectionRefusedError:                print('appium连接已断开')            except urllib.error.URLError:                print('appium连接已断开')